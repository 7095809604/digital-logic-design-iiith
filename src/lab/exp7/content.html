<!DOCTYPE html>
<head></head>
<span id="main-title">
Counters
</span>

<div id="introduction" header="Introduction">


<p>
In digital logic and computing, a counter is a device which stores (and sometimes displays) the number of times a particular event or process has occurred, often in relationship to a clock signal.
In this experiment, different types of counters will be studied, both for the full binary sequence and for cycle lengths (N) different from powers of 2.

</p>
	
</div>
<div id="theory" header="Theory">
<p>
Usually, counter circuits are digital in nature, and count in natural binary. Many types of counter circuits are available as digital building blocks, for example a number of chips in the 4000 series implement different counters.
Occasionally there are advantages to using a counting sequence other than the natural binary sequence such as the binary coded decimal counter, a linear feedback shift register counter, or a Gray-code counter.
Counters are useful for digital clocks and timers, and in oven timers, VCR clocks, etc.
<br />
The counters will be assembled using two 74LS73 dual J-K flip-flop chips and a 74LS02 quad NOR chip. Note that each flip-flop has an asynchronous Reset (R’) input besides the synchronous J-K inputs. This enables one to reset any of the flip-flops by making R’ = 0 irrespective of the status of the clock (CK) input. The asynchronous R’ input will be utilised in this experiment to initialise the flip-flop outputs as well as to obtain counters having cycle length N < 16.
<br />
<h3> Pin connections: </h3>
<img src="../images/counters.png">
<br />
<h2> Binary Ripple Counter </h2>
1. Make J = K = 1 for all the flip-flops, thereby converting the J-K flip-flops to T flip-flops. Connect all R’ inputs together to an Input Switch, and the outputs Q0,Q1,Q2,Q3 to four LED Displays.
<br />
2. Set up an Up-counting Binary Ripple Counter by making clock connections as follows: CK0 = Manual Clock (CLK-M), CK1 = Q0, CK2 = Q1, CK3 = Q2.
<br />
3. Using the Input Switch connected to the common R’ input, initialise the counter to the stat
<br />
4. Apply Manual Clock pulses and tabulate the state sequence for the entire cycle.
<br />
5. Now change the clock input connections to CK1 = Q0’, CK2 = Q1’, CK3 = Q2’, to obtain a Down-counting Binary Ripple counter.
<br />

<h2>Asynchronous (ripple) counter:</h2>
An asynchronous (ripple) counter is a single JK-type flip-flop, with its J (data) input fed from its own inverted output. This circuit can store one bit, and hence can count from zero to one before it overflows (starts over from 0). This counter will increment once for every clock cycle and takes two clock cycles to overflow, so every cycle it will alternate between a transition from 0 to 1 and a transition from 1 to 0. Notice that this creates a new clock with a 50% duty cycle at exactly half the frequency of the input clock. If this output is then used as the clock signal for a similarly arranged D flip-flop (remembering to invert the output to the input), you will get another 1 bit counter that counts half as fast. Putting them together yields a two-bit counter:
<br />
<br />
<table border="3">
	<tr><td>Cycle</td><td>Q1</td><td>Q2</td><td>(Q1:Q0)dec</td></tr>
	<tr><td>0</td><td>0</td><td>0</td><td>0</td></tr>
	<tr><td>1</td><td>0</td><td>1</td><td>1</td></tr>
	<tr><td>2</td><td>1</td><td>0</td><td>2</td></tr>
	<tr><td>3</td><td>1</td><td>1</td><td>3</td></tr>
	<tr><td>4</td><td>0</td><td>0</td><td>0</td></tr>
</table>

<br />
<br />
<h2>Synchronous counter:</h2>
A simple way of implementing the logic for each bit of an ascending counter (which is what is depicted in the image to the right) is for each bit to toggle when all of the less significant bits are at a logic high state. For example, bit 1 toggles when bit 0 is logic high; bit 2 toggles when both bit 1 and bit 0 are logic high; bit 3 toggles when bit 2, bit 1 and bit 0 are all high; and so on.
Synchronous counters can also be implemented with hardware finite state machines, which are more complex but allow for smoother, more stable transitions.
Hardware-based counters are of this type.

<br />
<br />
<h3>Decade counter:</h3>
A decade counter is one that counts in decimal digits, rather than binary. A decade counter may have each digit binary encoded (that is, it may count in binary-coded decimal, as the 7490 integrated circuit did) or other binary encodings (such as the bi-quinary encoding of the 7490 integrated circuit). Alternatively, it may have a "fully decoded" or one-hot output code in which each output goes high in turn (the 4017 is such a circuit). The latter type of circuit finds applications in multiplexers and demultiplexers, or wherever a scanning type of behavior is useful. Similar counters with different numbers of outputs are also common.
The decade counter is also known as a mod-counter when it counts to ten (0, 1, 2, 3, 4, 5, 6, 7, 8, 9). A Mod Counter that counts to 64 stops at 63 because 0 counts as a valid digit.
<br />
A decade counter has the count sequence 0 → 1 → 2 →.....→ 8 → 9 → 0.., which can be achieved by making R’ = (Q3 •Q1)’ for all the flip-flops in a 4-bit binary counter. This forces the counter to go to the state 0000 as soon as the counter makes the transition from the state 1001 representing count 9 to the next state 1010 according to the normal up counting sequence.
<h3>Decade synchronous counter </h3>
The logic for the J-K inputs required for a Decade Synchronous Counter is as follows:
<br />
J0 = K0 = 1; J1 = Q0•Q3’, K1 = Q0; J2 = K2 = Q0•Q1; J3 = Q0•Q1•Q2, K3 = Q0.

<h2>Multipurpose 4-bit Synchronous Counter</h2>
CD4029 is a multipurpose 4-bit counter capable of operating in all the four combinations of Binary/BCD and Up/Down modes, depending on the values of the control inputs B/D’ and U/D’.
<br />
In addition, the 4-bit output Q3Q2Q1Q0 of the counter can be preset to any value by applying the desired bits to the direct inputs D3D2D1D0 and making the Set ENable control SEN = 1.
<img src="../images/CD4029codes.png">


</p> 
</div>
<div id="objective" header="Objective">
<ol>
<li> The objective of this experiment is to understand working of  the counters. </li>
<li> Try to make basic ripple counter and ring counter.</li>
</ol>
</div> 
<div id="procedure" header="Procedure">
<ol>
<li> With The help of Theory Page , try to build the Counter Circuit. </li>
<li> First of all build the basic counter .</li>
<li> Then make the Ring Counter</li>
<li>If You are unable to make it , load or export the circuit directly and use it </li>
<li> Use Time variant input pulses to analyze the output <li>
</ol>
</div> 
<div id="experiment" header="Experiment">
<div id="test1"><applet code='dldvirtuallabs.simulationApplet' archive='../DLDVirtualLabs.jar' width="1201" height="1000">
<param name="file_name" value="line.txt">
<param name="content1" value="Make counter and also ring counter">
<param name="file_list" value="counter,ring_counter">


</applet>
</div>
</div>


<div id="manual" header="Manual">

	<div>
		<h2>Digital Logic Design</h2><br/>
		This experiment is designed to simulate any digital logical circuit.Following are the instruction for building the circuit.The whole Applet consist of mainly four pannels i.e Left Pannel , Mid Pannel , Right Pannel and Top Pannel.
		<ol>
		<li>
		<b>Left Pannel</b> 

		</li>
		<ol>
		<li>
			<b>Gate Buttons: </b> So this buttons are used to draw basic gates like and,or,exor,not,nor,nand and exnor .After clicking this you just have to click on mid pannel drawing area.
		</li>
	<li>
	<b>Probe:</b>Generaly terminal output is shown by default, if you want explicitly Input and output of various node , then you have to probe it.
</li>
<li>
	<b>None:</b>It is used to get default cursor option back, so that you can do basic operation like drag and drop .
</li>

<li><b>Delete Element:</b> This is used for explicitly deleting certain element. You just have to click on those element.
</li>
<li><b>Connect/Disconnect:</b>This used for establishing and removing connection between various element. Connection can be established only from output to input.You have to first click to the output node then to the input node(consist of red square box) . For disconnection , also same procedure but this time you can start by clicking either of  input or output node.</li>
<li><b>Naming:</b>This is used for giving name to either input or output node. Just click on the node, then one input box will pop out in which you can give the name.
</li>
<li><b>Output:</b>Generally this is used for explicitly defining yhe output node. Its purpose will be more clear in explanation of import button.</li>
<li><b>Time Pulse</b>You have to enter time pulse in definate pattern i.e <timepulse_name>:<uptime>,<downtime>,<uptime>,<downtime> and so on.For ex: 0,10,10,10,10 . After that press enter or click on the new timepulse. Then, it will be created and available as input in list box.</li>
<li><b>Binary One And Zero</b>These are used to give value to terminal input and output</b></li>
</ol>
<li><b>Top Pannel</b></li>
<ol>
<li><b>Clear:</b>It is used to clear every element on the circuit</li>
<li><b>Save:</b>It is used for saving the circuit as file which can be loaded and imported.</li>
<li><b>Load:</b>It load the save circuit as it is without any change. It would be fresh circuit with no previous value stored.</li>
<li><b>Import:</b>Now it is a very important feature. It is simmilar to load , but circuit will appear as black box with terminal input ,terminal output and those output which are set by the output button on left pannel. So, in this recursively you can make many circuit.The input and output nodes will come in order of top to bottom on the basis of there vertical position while saving.It is imported as geeneric element whose name is derived from saved file's name.</li>
<li><b>Simulate:</b>This is used to compute the whole circuit , if all the terminal inputs are present . It also compute the gate delays , which can be known by hovering the mouse over the gates. By default gate delay is kept to be -1. Simulation can fail or give ambiguous result if circuit do not stablizes with time. This generally happens in the case of improper construction of feedbacks. For ex : If You use direct feedback in flip flop it will give You wrong or no result , i.e why use master slave architecture to build flip flop. </li>
</ol>

<li><b>Mid Pannel:</b>It is the just drawing area used for building various circuits.You can move various element in mid pannel by simple drag and drop.</li>


<li><b>Right Pannel:</b>It is used for showing time varying terminal inputs ,outputs and also probed input and output.It will have element name and input or output index associated with it. Indexes are given top to bottom.</li>

</ol>
<li><b>Note:</b>There is sample circuit for each experiment is given at the home page. You can try them with the help of save or import button.</li>



</ol>
		
	</div>
	
</div>

<div id="quizzes" header="Quizzes">
<strong>	
	<p>
		1) Design a 4 bit Synchronous UP counter using 4 JK flip flops, a common clock pulse, and basic gates. 
		<br/><br/>
		2) Design a synchromous BCD counter which counts from 0000 (0) to 1001 (9) and then back to 0000 (0).You can use 'T' flip flops / Jk flip flops and some basic gates in the design. All the flip flops should have a common clock pulse. There must be a 'Count Enable' input which enables the counter. Save this counter so that it can be used in other designs.
		<br/><br/>
		3) Import the BCD counter designed in 2nd question. Import 3 such counters. Design a 3-decade decimal counter using these 3 BCD counters. The entire system should be able to count from 000 to 999, where each counter individually generates 1 digit of the number. <br/><br/>
		HINT: The 'Count enable' input of 2nd BCD counter will be 1 only when first counter is at 9, and 'Count enable' of 3rd counter will be 1 only when both first and second counters are at 9.
		<br/><br/>		
		4) Import the BCD to seven segment display decoder circuit designed in experiment 3. It takes BCD code as input and displays its decimal equivalent on 7-segment LED display. Import the BCD counter designed in question 2. Connect the output lines of BCD counter to the input lines of 'BCD to seven segment display' circuit. Verify that appropriate number is being displayed by the LED in the count sequence.
		</p>
</strong> 
</div>

<div id="reading" header="Further Reading"> 
	<ol>	
		<li>
			<a href="http://en.wikipedia.org/wiki/Counter" target="_blank"> Counters - Wikipedia </a>
		</li>
		<li>
			Chapter 7 : Registers, Counters and Memory unit, "Digital Logic and Computer Design" - M. Morris Mano
		</li>
	</ol>
</div>

